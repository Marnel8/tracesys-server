# üèóÔ∏è Server Architecture Workflow Rules

## üìã Overview
This server follows a **layered architecture pattern** with clear separation of concerns. **ALWAYS identify and follow the existing workflow pattern** before making any changes.

## üîÑ Current Architecture Flow
```
Request ‚Üí Routes ‚Üí Controllers ‚Üí Services ‚Üí Data Layer ‚Üí Models ‚Üí Database
                     ‚Üì
Response ‚Üê Controllers ‚Üê Services ‚Üê Data Layer ‚Üê Models ‚Üê Database
```

## üìÅ Directory Structure & Responsibilities

### `/src/db/models/` - Database Models
- **Purpose**: Define database schema, relationships, and model-level business logic
- **Pattern**: Use Sequelize-TypeScript decorators
- **Responsibilities**:
  - Table definitions with `@Table`, `@Column` decorators
  - Relationships with `@HasMany`, `@BelongsTo`, etc.
  - Model-level methods (e.g., `SignAccessToken()`, `comparePassword()`)
  - Hooks with `@BeforeCreate`, `@BeforeUpdate`
  - Enums for type safety
- **Example**: `user.ts` with User model, UserRole, UserType enums

### `/src/db/index.ts` - Database Configuration
- **Purpose**: Sequelize connection setup and model registration
- **Pattern**: Single database instance export
- **Responsibilities**:
  - Database connection configuration
  - Model registration in Sequelize constructor
  - Authentication and synchronization

### `/src/data/` - Data Access Layer
- **Purpose**: Database operations and queries
- **Pattern**: Pure functions that interact with models
- **Responsibilities**:
  - CRUD operations
  - Complex queries
  - Transaction management
  - Error handling for database operations
- **Naming**: `find*`, `create*`, `update*`, `delete*` functions
- **Example**: `findUserByID()`, `createUserData()`, `login()`

### `/src/services/` - Business Logic Layer
- **Purpose**: Business logic that doesn't fit in models or data layer
- **Pattern**: Pure functions for business operations
- **Responsibilities**:
  - Complex business logic
  - External service integrations
  - Token generation
  - Email operations
- **Example**: `createActivationToken()`

### `/src/controllers/` - Request/Response Handling
- **Structure**: Each feature has its own folder with `index.ts` and `routes.ts`
- **Pattern**: 
  - `index.ts`: Controller functions
  - `routes.ts`: Route definitions
  - Main `routes.ts`: Aggregates all feature routes

#### Controller Functions (`/controllers/[feature]/index.ts`)
- **Purpose**: Handle HTTP requests and responses
- **Pattern**: Async functions with `(req: Request, res: Response)` signature
- **Responsibilities**:
  - Request validation
  - Call services/data layer
  - Response formatting
  - Error handling (throw custom errors)
- **Naming**: `[action][Feature]Controller` (e.g., `registerUserController`)

#### Route Definitions (`/controllers/[feature]/routes.ts`)
- **Purpose**: Define HTTP routes and middleware
- **Pattern**: Express Router with middleware chaining
- **Responsibilities**:
  - Route path definitions
  - HTTP method mapping
  - Middleware application (auth, upload, etc.)
  - Controller function binding

### `/src/middlewares/` - Cross-cutting Concerns
- **Purpose**: Reusable middleware functions
- **Pattern**: Express middleware functions
- **Current Middlewares**:
  - `auth.ts`: Authentication middleware
  - `error-handler.ts`: Global error handling

### `/src/utils/` - Utility Functions
- **Purpose**: Reusable helper functions
- **Pattern**: Pure functions, no side effects
- **Current Utils**:
  - `jwt.ts`: JWT token utilities
  - `error.ts`: Custom error classes
  - `send-mail.ts`: Email utilities
  - `uploader.ts`: File upload utilities

### `/src/@types/` - Type Definitions
- **Purpose**: TypeScript interfaces and types
- **Pattern**: Feature-based type organization

## üöÄ Development Workflow

### 1. **IDENTIFY EXISTING PATTERNS FIRST**
Before adding new features, examine existing code:
- Check similar features for patterns
- Follow the same naming conventions
- Use the same error handling approach
- Maintain the same layer separation

### 2. **Adding New Features**
Follow this order:
1. **Models** (`/db/models/`): Define database schema
2. **Data Layer** (`/data/`): Create data access functions
3. **Services** (`/services/`): Add business logic if needed
4. **Controllers** (`/controllers/[feature]/`): Create controller and routes
5. **Routes** (`/controllers/routes.ts`): Register new routes
6. **Types** (`/@types/`): Add TypeScript definitions

### 3. **Error Handling Pattern**
- Use custom error classes from `/utils/error.ts`
- Throw errors in data/service layers
- Let error middleware handle responses
- Common errors: `BadRequestError`, `NotFoundError`, `ConflictError`, `UnauthorizedError`

### 4. **Authentication Pattern**
- Use `isAuthenticated` middleware from `/middlewares/auth.ts`
- Access user via `req.user` in authenticated routes
- Use JWT utilities from `/utils/jwt.ts`

### 5. **Database Transaction Pattern**
```typescript
const t = await sequelize.transaction();
try {
  // database operations
  await t.commit();
} catch (error) {
  await t.rollback();
  throw error;
}
```

## üéØ Key Principles

1. **Separation of Concerns**: Each layer has a specific responsibility
2. **Consistency**: Follow existing patterns and naming conventions
3. **Error Handling**: Use custom error classes and centralized error handling
4. **Type Safety**: Use TypeScript interfaces and enums
5. **Transaction Safety**: Use database transactions for critical operations
6. **Authentication**: Protect routes with middleware
7. **Validation**: Validate inputs at controller level

## üö´ Anti-Patterns to Avoid

- Don't put business logic in controllers
- Don't put database queries in controllers
- Don't mix concerns between layers
- Don't create new patterns without justification
- Don't skip error handling
- Don't ignore existing naming conventions

## üìù Naming Conventions

- **Models**: PascalCase (e.g., `User`, `Project`)
- **Files**: kebab-case (e.g., `user.ts`, `error-handler.ts`)
- **Functions**: camelCase with descriptive prefixes
  - Controllers: `[action][Feature]Controller`
  - Data: `[action][Feature]Data` or `find*`, `create*`
  - Services: `[action][Feature]Service` or descriptive names
- **Routes**: RESTful patterns (`/api/v1/user/`, `/api/v1/user/me`)
- **Variables**: camelCase
- **Constants**: UPPER_SNAKE_CASE
- **Enums**: PascalCase

## üîç Before Making Changes

1. **Analyze**: Study existing similar features
2. **Plan**: Identify which layers need changes
3. **Follow**: Use the same patterns and conventions
4. **Test**: Ensure your changes fit the existing workflow
5. **Document**: Update types and interfaces as needed

Remember: **Consistency is key**. Always follow the established patterns rather than creating new ones. 